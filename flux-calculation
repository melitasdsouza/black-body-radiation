# These are constants we will need for our functions, using the astropy package
c = const.c.cgs.value # cm/s
k = const.k_B.cgs.value # erg/K
h = const.h.cgs.value # erg s

# This function converts magnitudes to fluxes, given the magnitude, error, and band.
def mag_to_flux(mag, mag_err, band):
    """Calculate flux in erg s-1 cm-2 Å-1."""
    if 'PS1' in band or 'SDSS' in band or 'GALEX' in band: # For AB magnitudes, convert flux using standard AB magnitude zero point (48.6)
        flux = 10 ** (-.4 * (mag + 48.6))
        flux_err = abs(-.4 * flux * np.log(10) * mag_err)
        wl_eff = get_effective_wavelength(band) # Retrieves the effective wavelength by calling another function
        flux = Fnu_to_Flam(flux, wl_eff) # Converts Fν (flux per Hz) to Fλ (flux per Å), using another function
        flux_err = Fnu_to_Flam(flux_err, wl_eff)
    else: # For Vega magnitudes, simply retrieve the zero point flux and apply the standard magnitude-to-flux conversion
        f0 = get_zero_flux(band)
        flux = 10 ** (-.4 * mag) * f0
        flux_err = abs(-.4 * flux * np.log(10) * mag_err)
    return flux, flux_err

# This function retrieves the zero point flux from the SVO table, given the filter.
def get_zero_flux(band):
    """Retrieve zero flux from SVO table."""
    row = df_SVO[df_SVO["name"] == band]
    
    if row.empty: # Checks if the band isn't in the table
        print(f"Warning: Zero flux not found for band {band}. Assigning NaN.")
        return np.nan
    
    if "AB" in band or "SDSS" in band or "PS1" in band or "GALEX" in band:
        return row["AB flux"].values[0]  # Return AB zero point flux
    else:
        return row["Vega flux"].values[0]  # Return Vega zero point flux

# This function retrieves the effective wavelength from the SVO table, given the filter.
def get_effective_wavelength(band):
    """Retrieve the effective wavelength from SVO table and ensure it is in Ångströms."""
    row = df_SVO[df_SVO["name"] == band]
    
    if row.empty:
        print(f"Warning: Effective wavelength not found for band {band}. Assigning NaN.")
        return np.nan
    
    wavelength = row["effective wavelength"].values[0]
    unit = row["wavelength units"].values[0]

    # Convert nanometers to Ångströms if necessary
    if unit.lower() in ["nm", "nanometers"]:
        wavelength *= 10  # 1 nm = 10 Å

    return wavelength  # Return wavelength in Å

# This function converts the flux in frequency to flux in wavelength
def Fnu_to_Flam(f_nu, wl):
    f_lam = f_nu * (c) / (wl)**2 * 1E8 # 1 cm = 1E8 Å, units: erg/s/cm^2/Å
    return f_lam

# This function converts the flux in wavelength to flux in frequency
def Flam_to_Fnu(f_lam, wl):
    f_nu = f_lam * (wl)**2 / (c) / 1E8 # 1 cm = 1E8 Å, units: erg/s/cm^2/Hz
    return f_nu
# This computes the fluxes for all bands.
def compute_fluxes(df):
    df = df.copy() # Avoid modifying the original dataframe and prevent an error

    # Map the input band names from our data table to the standardized band names in the SVO table
    band_mapping = {
        'uvw1': 'UVOT_UVW1', 'uvm2': 'UVOT_UVM2', 'uvw2': 'UVOT_UVW2',
        'NUV': 'GALEX_NUV', 'FUV': 'GALEX_FUV',
        'B': 'Johnson_B', 'V': 'Johnson_V', 'I': 'Cousins_I', 'u': 'Thuan-Gunn_u',
        'g_mag': 'Gaia_G', 'j_m': '2MASS_J'
    }
    
    error_mapping = {
        'UVOT_UVW1': 'uvw1 error', 'UVOT_UVM2': 'uvm2 error', 'UVOT_UVW2': 'uvw2 error',
        'GALEX_NUV': 'eNUV', 'GALEX_FUV': 'eFUV',
        'Johnson_B': 'B error', 'Johnson_V': 'V error', 'Cousins_I': 'I error', 'Thuan-Gunn_u': 'u error',
        'Gaia_G': 0.03, '2MASS_J': 'j_msigcom'
    }

    # Iterate over each band in the mapping
    for band, std_band in band_mapping.items():
        error_col = error_mapping.get(std_band, None)  # Lookup error based on standardized band name
        
        # print(f"Processing band: {band} → {std_band} | Error Column: {error_col}")  # Use for debugging

        if isinstance(error_col, str) and error_col in df.columns:
            # If an explicit error column exists, use its values
            df[[f'{std_band}_flux', f'{std_band}_flux_err']] = df.apply(
                # the lambda keyword can be used for short, simple operations 
                lambda row: mag_to_flux(row[band], row[error_col] if pd.notna(row[error_col]) else np.nan, std_band)
                # axis = 1 is for row-wise operations; result_type='expand' returns two separate columns for flux and flux_err
                if pd.notna(row[band]) else (np.nan, np.nan), axis=1, result_type='expand' 
            )
        else:
            # If no explicit error column exists, use an assumed error value (needed for Gaia photometry)
            assumed_error = error_col if isinstance(error_col, (int, float)) else np.nan
            df[[f'{std_band}_flux', f'{std_band}_flux_err']] = df.apply(
                lambda row: mag_to_flux(row[band], assumed_error, std_band)
                if pd.notna(row[band]) else (np.nan, np.nan), axis=1, result_type='expand'
            )

    return df
